#!/usr/bin/env bash

# ni_info : Network Interface info
# 
# Initially a way to collect DNS addresses for configuring a
# DHCP server, this utility may level-up with additional features
# if future needs suggest.

source bash_clargs

declare OIFS="$IFS"
declare IFS=$'\n'

declare -a CLOPTS=(
    "h|->show_usage|Show options usage"
    "l|->list_interfaces|List active network interfaces"
    "d|->build_dns_info|Creates a DNS information report"
    "a|+>interface_addresses|Get interface DNS addresses"
    "q|->quick_info|Quick get CSV nameservers"
)
IFS="$OIFS"

declare -i OPTION_USED=0

set_option_used()
{
    local -n ou="OPTION_USED"
    ou=1
}

# Using Extended posix regular expression, treat special
# characters like (, {, ., etc as regex characters, and these
# characters must be escaped if they are to matched as text.
#
# This syntax works for BASH =~ as well as sed -E, so we can
# reuse this expression.
declare basic_ip_regex='([[:digit:]]{1,3})((.[[:digit:]]{1,3}){3})'

declare -A NETLINKS=()

# Function to populate the global array, NETLINKS
collect_netlinks()
{
    local -n links="NETLINKS"
    local IFS=$'|'

    declare -a sections=( $( resolvectl status | sed 's/^[[:alnum:]][^:]\+$/|\0/' ))

    declare section line
    declare -a lines
    IFS=$'\n'
    for section in "${sections[@]}"; do
        lines=( $section )
        if [ "${#lines[@]}" -gt 1 ]; then
            if [[ "$section" =~ ^Link[[:space:]][[:digit:]]+[[:space:]]\(([[:alnum:]]+)\) ]]; then
                # Replace first line of section with interface name
                links["${BASH_REMATCH[1]}"]="${lines[*]:1}"
            else
                links["${lines[@]:0:1}"]="${lines[*]:1}"
            fi
        fi
    done
}

# Test if a link contains DNS servers
test_for_dns_scope()
{
    [[ "$1" =~ [[:space:]]+Current[[:space:]]Scopes:[^\\n]+DNS[^\\n] ]];
}

# Test if a line introduces DNS Server IP addresses:
test_first_dns_address()
{
    [[ "$1" =~ ^[[:space:]]+DNS\ Servers:\ ${basic_ip_regex}$ ]]
}

# Collect DNS ip addresses from a link
collect_dns_ip_addresses()
{
    if [ "${#1}" -eq 0 ]; then
        echo "Empty interface specs string." >&2
        exit
    fi

    local IFS=$'\n'
    local -a lines=( $1 )
    local line
    local -i collecting=0
    for line in "${lines[@]}"; do
        if [ "$collecting" -eq 0 ]; then
            if  test_first_dns_address "$line"; then
                collecting=1
                if [[ "$line" =~ $basic_ip_regex ]]; then
                    echo -n "${BASH_REMATCH[0]}"
                else
                    echo "Error, expected to find an IP address on this line." >&2
                fi
            fi
        elif [ $collecting -eq 1 ]; then
            if [[ "$line" =~ $basic_ip_regex ]]; then
                echo -n " ${BASH_REMATCH[0]}"
            else
                break
            fi
        fi
    done
}

# Debugging function, not used for now
collect_dnservers()
{
    local key linktext
    for key in "${!NETLINKS[@]}"; do
        linktest="${NETLINKS[$key]}"
        if test_for_dns_scope "$linktest"; then
            collect_dns_ip_addresses "$linktest"
            echo
        fi
    done
}


# bash_clargs functions
list_interfaces()
{
    set_option_used
    
    local key
    local seper
    for key in "${!NETLINKS[@]}"; do
        if [ "$seper" ]; then
            echo -n "$seper"
        else
            seper=' '
        fi

        echo -n "$key"
    done
    echo
}

interface_addresses()
{
    set_option_used

    if [ "$#" -eq 0 ]; then
        echo "The -${CUR_OPT} option requires a value."
    else
        local linkinfo="${NETLINKS[$1]}"
        if [ "$linkinfo" ]; then
            collect_dns_ip_addresses "$linkinfo"
        else
            echo "Unknown interface name [32;1m$1[m"
        fi
    fi
}

show_usage()
{
    set_option_used

    echo "With no parameters, this command will return the most"
    echo "useful array, the DHCP-assigned interface name and the"
    echo "DNS IP addresses assigned to that interface."
    echo
    echo "Otherwise, the following options are available:"
    bash_clargs_usage
}

build_dns_info()
{
    set_option_used

    local key linktext
    for key in "${!NETLINKS[@]}"; do
        linktest="${NETLINKS[$key]}"
        echo -n "$key"
        if test_for_dns_scope "$linktest"; then
            # Separate name from dns ip addresses
            echo -n " "
            collect_dns_ip_addresses "$linktest"
        fi
        echo
    done
}

quick_info()
{
    local IFS=$'\n'
    local -a lines=( $( build_dns_info ) )
    local -a parts
    local -a ips=()

    local line addr
    
    IFS=$' '
    for line in "${lines[@]}"; do
        parts=( $line )
        if [ "${#parts[*]}" -gt 1 ]; then
            for addr in "${parts[@]:1}"; do
                ips=( "${ips[@]}" $addr )
            done
        fi
    done

    local -i add_comma=0
    for addr in "${ips[@]}"; do
        if [ "$add_comma" -eq 0 ]; then
            add_comma=1
        else
            echo -n ", "
        fi
        echo -n "$addr"
    done

    echo
}


collect_netlinks
# collect_dnservers

bash_clargs_process "$@"
if [ "$OPTION_USED" -eq 0 ]; then
    quick_info
fi

