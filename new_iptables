#!/usr/bin/env bash

source nif_info

declare ETH_EXT=$( nif_find_external_name )
declare ETH_INT=$( nif_find_first_internal_name )
declare IP_INT=$( nif_find_first_internal_addr )
declare INT_NET=$( nif_network_source_address "$IP_INT" )
declare SAVE_SETTINGS=0

source bash_clargs

declare -a CLOPTS=(
    "h|->bash_clargs_usage|Show options"
    "i|ETH_INT|Set internal interface name"
    "e|ETH_EXT|Set external interface name"
    "a|INT_NET|Set LAN IP Address range"
    "s|-SAVE_SETTINGS|Save settings at script termination (otherwise iptables set to permissive)"
)

# The starting point for this version of an iptables-generating script
# (broke super-long URL into an array to keep shorter lines).
open_inspiration_page()
{
    local -a uparts=(
        "https://"
        "www.digitalocean.com/"
        "community/"
        "tutorials/"
        "how-to-implement-a-basic-"
        "firewall-template-with-"
        "iptables-on-ubuntu-14-04"
    )

    local IFS=$''
    browse "${uparts[*]}" &
}

declare MPR=/sbin/modprobe
declare IPT=/sbin/iptables

is_root() { [ "$USER" = "root" ]; }

ipt_debug()
{
    local IFS=$' '
    /sbin/iptables "${@:1}"
    if [ "$?" -ne 0 ]; then
        echo "[31;1mIPTABLES failure[m with arguments [33;1m${*:1}[m"
    fi
}

# optional parameter to set DROP (default) or ACCEPT
ipt_flush()
{
    local policy="${1:-DROP}"

    $IPT -F           # Delete all chain rules
    $IPT -F -t nat
    $IPT -F -t raw

    $IPT -X           # Delete non-built-in chains

    # Set policies to DROP if not explicitely accepted
    $IPT -P INPUT $policy
    $IPT -P OUTPUT $policy
    $IPT -P FORWARD $policy

    # Use connection tracking modules
    $MPR nf_conntrack
    $MPR iptable_nat
    $MPR ipt_iprange
}

ipt_generic_tables_rules()
{
    local table="$1"

    # drop invalid
    $IPT -A $table -m state --state INVALID -j DROP
    
    # accept established
    $IPT -A $table -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    if [ "$table" != "OUTPUT" ]; then
        if [ "${#INT_NET}" -gt 8 ]; then
            # drop spoofedn (from LAN interface without LAN address)
            $IPT -A $table -i $ETH_INT ! -s $INT_NET -j DROP
        else
            echo "Failed to add anti-spoofing rule due to missing INT_NET value."
        fi
    fi

    $IPT -A $table -p icmp --icmp-type echo-request -j ACCEPT
}

ipt_permissive_forward_rules()
{
    ipt_generic_tables_rules "FORWARD"

    # Allow everything out:
    $IPT -A FORWARD -i $ETH_INT -o $ETH_EXT -j ACCEPT

    # Fall out to default DROP polify
}

declare DEF_RULE_ARGS=( -m state --state NEW -j ACCEPT )

ipt_add_rule()
{
    local table="${1^^}"
    local -i port="$2"
    local proto="$3"

    local -a args=( "${DEF_RULE_ARGS[@]}" )

    if [ "$proto" = "tcp" ]; then
        args=( --syn "${args[@]}" )
    fi

    if [ "$#" -gt 3 ]; then
        args=( "${@:4:}" "${args[@]}" )
    fi

    args=(
        -A "$table"
        -p "$proto"
        --dport "$port"
        "${args[@]}"
    )

    # echo "args are [32;1m${args[*]}[m"
    $IPT "${args[@]}"
}

ipt_add_nat_forward_out_rule()
{
    local IFS=$' '
    local -a aport=( $1 )
    local -a protos=()

    local proto port

    # Break down line, save port and protocols, skip all following a '#'
    for proto in "${aport[@]}"; do
        if [ "${proto:0:1}" = '#' ]; then
            break
        elif [ -z $port ]; then
            port=$proto
        else
            protos=( "${protos[@]}" $proto )
        fi
    done

    if [ "$port" ]; then
        # Unspecified protocol, use tcp
        if [ "${#protos[@]}" -eq 0 ]; then
            protos=( tcp )
        fi

        for proto in "${protos[@]}"; do
            if [ "$proto" = "tcp" ]; then
                $IPT -A FORWARD -p $proto -i $ETH_INT --dport $port --syn -m state --state NEW -j ACCEPT
            elif [ "$proto" = "udp" ]; then
                $IPT -A FORWARD -p $proto -i $ETH_INT --dport $port -m state --state NEW -j ACCEPT
            else
                echo "Port protocol [32;1m$proto[m is not recognized."
            fi
        done
    fi
}

ipt_restrictive_forward_rules()
{
    ipt_generic_tables_rules "FORWARD"

    $IPT -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT

    if [ -f ipt_forward_ports ]; then
        local IFS=$'\n'
        local -a ports=( $( cat ipt_forward_ports ) )
        local -a aport
        for port in "${ports[@]}"; do
            ipt_add_nat_forward_out_rule $port
        done
    fi

    $IPT -A FORWARD -p icmp --icmp-type echo-request -j ACCEPT

    # Fall out to default DROP polify
}

ipt_generic_input_rules()
{
    ipt_generic_tables_rules "INPUT"
    
    # Accepting packets by port
    ipt_add_rule INPUT 22 tcp -i $ETH_INT
    # $IPT -A INPUT -p tcp --dport 22 -i $ETH_INT -j ACCEPT

    # Accepting packets by interface
    $IPT -A INPUT -i lo -j ACCEPT
}

ipt_generic_output_rules()
{
    ipt_generic_tables_rules "OUTPUT"

    ipt_add_rule output 53 tcp -o $ETH_OUT    # allow DNS requests
    ipt_add_rule output 53 udp -o $ETH_OUT    # allow DNS requests

    ipt_add_rule output 80 tcp    # allow http requests
    ipt_add_rule output 443 tcp   # allow https requests (for git)
    ipt_add_rule output 9418 tcp  # allow unauthenticated git requests
 
    ipt_add_rule output 123 udp   # allow NTP (network time protocol)
}


ipt_nat_rules()
{
    # $IPT -t nat -A POSTROUTING -s "$INT_NET" -o "$ETH_EXT" -j MASQUERADE
    $IPT -t nat -A POSTROUTING -o "$ETH_EXT" -j MASQUERADE

    # Using an array in case it's appropriate to make
    # multiple changes in sysctl.conf
    local -a args=(
        -e 's/#\(net.ipv4.ip_forward\.*\)/\1/'
    )

    sed -i "${args[@]}" /etc/sysctl.conf

    # enable ip forwarding and dynamic addressing:
    echo 1 > /proc/sys/net/ipv4/ip_forward

    # This line seems to be no longer necessary:
    # echo 1 > /proc/sys/net/ipv4/ip_dynaddr
}

main()
{
    ipt_flush

    ipt_generic_input_rules
    ipt_generic_output_rules

    ipt_restrictive_forward_rules

    ipt_nat_rules
}

bash_clargs_process "$@"

if is_root; then
    IPT="ipt_debug"
    main
    echo "[32;1m"
    iptables-save
    echo "[m"

    if [ "$SAVE_SETTINGS" -eq 0 ]; then
        ipt_flush "ACCEPT"
    fi
else
    echo "Must be root to run."
fi
