#!/usr/bin/env bash

# For commandline processing

declare -a CLOPTS=(
    "h|->bash_clargs_usage|Show help"
    "e|IF_EXT|Set external interface name"
    "i|IF_INT|Set internal interface name"
    "n|INT_NET|Set internal internet base address"
    "s|-SKIP_INTERACTIVE|Skip setting parameters interactively."
    "w|-WRITE_CONFIGS|Write configuration files.  Must be root."
)

source bash_clargs


# This script file collects network information
source nif_info

declare IF_EXT
declare IF_INT
declare INT_NET=192.168.10.0
declare -i SKIP_INTERACTIVE=0
declare -i WRITE_CONFIGS=0

clear_screen() { echo -n "[2J"; }
is_root() { [ "$USER" = "root" ]; }
is_write_mode() { [ "$WRITE_CONFIGS" -eq 1 ]; }

get_keypress()
{
    local prompt="${1:=Press any key}"

    local IFS=''

    # Array to collect chars in case of multi-char keypress
    local -a chars=( )
    
    # Wait for a keypress (-n 1), save to array
    local keychar
    read -n 1 -s -p "${prompt}" keychar
    chars=( "$keychar" )

    # Collect additional characters if available, especially for escape characters
    while read -t 0; do
        read -n 1 keychar
        chars=( "${chars[@]}" "$keychar" )
    done

    # empty IFS so array is joined without delimiters
    echo "${chars[*]}"
}

set_network_defaults()
{
    local iface
    local name
    for iface in "${IFACES[@]}"; do
        name=$( nif_get_name "$iface" )
        if nif_is_external "$iface"; then
            IF_EXT=$name
        else
            IF_INT=$name
        fi

        if [ "$IF_EXT" ] && [ "$IF_INT" ]; then
            break
        fi
    done
}

get_ip4_address()
{
    local -n ret_val="$1"
    local IFS=$'.'
    local -a aparts=( $2 )

    local hilite="[32;1m"
    local unlite="[m"

    local -i position=0
    local -i index
    local part
    local -i curpart
    local resp

    # Do not leave IFS='.' or periods will be invisible to the 'read' command
    IFS=''

    while true; do
        clear_screen

        # Print IP address with current spot highlighted:
        index=0
        for part in "${aparts[@]}"; do
            if [ "$index" -gt 0 ]; then
                echo -n '.'
            fi
            if [ "$index" -eq "$position" ]; then
                echo -n "$hilite"
            fi
            echo -n "${part}${unlite}"
            (( ++index ))
        done
        echo

        curpart="${aparts[$position]}"

        resp=$( get_keypress "Type a number to set, period to advance, s to save, q to quit. ")
        # read -n 1 -r -p "Type a number to set, period to switch, s to save, q to quit. " resp
        echo 
        echo "resp has ${#resp} characters, is $resp"
        if [[ "$resp" =~ [0-9] ]]; then
            curpart="${curpart}${resp}"
            aparts[$position]="$curpart"
        elif [ "$resp" = '.' ]; then
            (( ++position ))
        elif [ "$resp" = 's' ]; then
            IFS=$'.'
            ret_val="${aparts[*]}"
            return 0
        elif [ "$resp" = 'q' ]; then
            return 1
        elif [ "${#resp}" -eq 1 ]; then
            printf "The single character is %d." "'$resp"
            read -n1
        else
            echo "resp is ${#resp} characters long: $resp"
            read -n1
        fi
    done
}

get_iface_name_index()
{
    local curname="$1"

    local -i index=0
    local name

    local iface
    for iface in "${IFACES[@]}"; do
        name=$( nif_get_name "${IFACES[$index]}" )
        if [ "$curname" = "$name" ]; then
            echo "$index"
            return 0
        fi
        (( ++index ))
    done
    return 1
}

show_interface_choices()
{
    local curchoice=$( nif_get_name "$1" )
    local direction="$2"
    local namecol="[1;4m"
    local defcol="[m"
    local curcol

    local iface
    local name
    local addr
    local index=1

    clear_screen
    echo "curchoice is [33;1m$curchoice[m and direction is [33;1m$direction[m"
    echo "Select a device for the [36;1m$direction[m interface."
    echo "The ${namecol}current selection${defcol} is highlighted."
    echo

    for iface in "${IFACES[@]}"; do
        name=$( nif_get_name "$iface" )
        addr=$( nif_get_addr "$iface" )
        if [ $? -ne 0 ]; then
            addr="NA"
        fi

        echo -n "name is [33;1m$name[m  "

        if [ "$name" = "$curchoice" ]; then
            curcol="$namecol"
        else
            curcol="$defcol"
        fi

        echo "$index. ${curcol}$name${defcol} ($addr)"
        (( ++index ))
    done

}

select_interface()
{
    local -n ret_val="$1"
    ret_val=

    local name_iface="$2"
    local type_iface="$3"
    local resp
    local -i max_index="${#IFACES[@]}"
    local -i cur_index=$( get_iface_name_index "$name_iface" )
    local -i sel_index

    while true; do
        show_interface_choices "$name_iface" "$type_iface"
        echo "q. to keep current choice"
        echo
        read -n 1 -p "Select an interface: " resp
        echo

        case "$resp" in
            [1-9] )
                sel_index=$(( $resp - 1 ))
                if [ "$sel_index" -lt "$max_index" ]; then
                    ret_val=$( nif_get_name "${IFACES[$sel_index]}" )
                    return 0
                fi
                ;;
            q ) break ;;
        esac
    done

    return 1
}

show_network_defaults()
{
    clear_screen
    echo "1. IF_EXT is [33;1m$IF_EXT[m"
    echo "2. IF_INT is [33;1m$IF_INT[m"
    echo "3. INT_NET is [33;1m$INT_NET[m"
}

make_date_suffix() { date +%Y%m%d.%H%M%S; }

backup_script()
{
    local target="$1"
    if [ -f "$target" ]; then
        local new_target="$target.$( make_date_suffix )"
        echo "Saving [32;1m$target[m to [32;1m$new_target[m"
        # mv "$target" "$new_target"
    fi
}

generate_dhcpd()
{
    local -a args=(
        -a "$INT_NET"
        -l "$IF_INT"
        -w "$IF_EXT"
    )

    local target="$1"

    if is_write_mode; then
        backup_script "$target"
        # ./build_dhcpd_conf > "$target"
    else
        echo
        echo "[33;1m$target[m:"
        ./build_dhcpd_conf
        echo
    fi
}

confirm_network_defaults()
{
    local -n if_ext="IF_EXT"
    local -n if_int="IF_INT"
    local -n int_net="INT_NET"
    local resp
    local new_iface
    local new_address
    while true; do
        show_network_defaults
        echo "a. to accept defaults"
        echo "q. to quit"
        echo 
        read -n 1 -p "Type a number " resp
        echo
        case "$resp" in
            1 )
                if select_interface new_iface "$if_ext" "external"; then
                    if_ext="$new_iface"
                fi ;;
            2 )
                if select_interface new_iface "$if_int" "internal"; then
                    if_int="$new_iface"
                fi ;;
            3 ) if get_ip4_address new_address "$int_net"; then
                    int_net=$new_address
                fi ;;
            a ) break ;;
            q ) exit 0 ;;
            * ) echo "Unknown entry.  Try again." ;;
        esac
    done
}


set_network_defaults

bash_clargs_process "$@"

bash_clargs_show

if [ "${SKIP_INTERACTIVE}" -eq 0 ]; then
    confirm_network_defaults
fi

if is_write_mode; then
    if is_root; then
        echo "About to write firewall script dhcpd.conf"
        generate_dhcpd "/etc/dhcp/dhcpd.conf"
    else
        echo "Must be root to write scripts."
    fi
else
    generate_dhcpd "/etc/dhcp/dhcpd.conf"
fi

